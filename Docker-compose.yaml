#src: https://github.com/docker-library/docs/blob/master/postgres/README.md
# Use postgres/example user/password credentials
version: '3.1'

services:

  db:
    image: postgres
    container_name: postgres
    restart: always
    environment:
      POSTGRES_PASSWORD: example

  adminer:
    image: adminer
    container_name: adminer_interface
    restart: always
    ports:
      - 8080:8080
    depends_on:
      - db

  networks:
    default:
      name: intranet


# Run docker-compose -f Docker-compose.yml up,
#wait for it to initialize completely, and visit http://swarm-ip:8080, http://localhost:8080, or http://host-ip:8080 (as appropriate).

#If you would like to do additional initialization in an image derived from this one, add one or more *.sql, *.sql.gz, or *.sh scripts
# under /docker-entrypoint-initdb.d (creating the directory if necessary). After the entrypoint calls initdb to create the default postgres user and database,
# it will run any *.sql files, run any executable *.sh scripts, and source any non-executable *.sh scripts found in that directory to do further initialization before starting the service.


# Warning: scripts in /docker-entrypoint-initdb.d are only run if you start the container with a data directory that is empty;
# any pre-existing database will be left untouched on container startup. One common problem is that if one of your /docker-entrypoint-initdb.d scripts fails
# (which will cause the entrypoint script to exit) and your orchestrator restarts the container with the already initialized data directory, it will not continue on with your scripts.

  # $ docker exec -it main_container_full_name psql -h postgresdb -U docker mydatabase